#include "Split.hpp"
#include "ProblemGeometry.hpp"
#include <limits>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <deque>

using namespace LcVRPContest;

Split::Split(const ThreadSafeEvaluator* evaluator)
    : evaluator_(evaluator) {
    capacity_ = evaluator_->GetCapacity();
    depot_idx_ = 0; // Zak³adamy 0 (zale¿ne od konwencji ProblemData)
    num_customers_ = evaluator_->GetSolutionSize();

    // MEMORY POOL - Rezerwacja pamiêci RAZ na ca³e ¿ycie obiektu
    int size = num_customers_ + 100;
    ResizeStructures(size);

    votes_buffer_.resize(evaluator_->GetNumGroups(), 0);
    segments_buffer_.reserve(size);
}

void Split::ResizeStructures(int size) {
    if ((int)D_.size() < size) {
        D_.resize(size);
        Q_.resize(size);
        V_.resize(size);
        pred_.resize(size);
    }
}

void Split::ApplyMicroSplit(Individual& indiv, int start_idx, int end_idx, const ProblemGeometry* geometry) {
    std::vector<int>& genes = indiv.AccessGenotype();
    const std::vector<int>& giant_tour = evaluator_->GetPermutation();
    int gt_size = static_cast<int>(giant_tour.size());
    int num_groups = evaluator_->GetNumGroups();
    int capacity = evaluator_->GetCapacity();

    if (start_idx < 0 || end_idx >= gt_size || start_idx > end_idx) return;

    int count = end_idx - start_idx + 1;

    // 1. Inicjalizacja Struktur (Bez realokacji - u¿ywamy istniej¹cych wektorów)
    ResizeStructures(count + 5);

    D_[0] = 0.0;
    Q_[0] = 0;
    V_[0] = 0.0;

    // 2. Prekomputacja (Cumulative Distance & Demand)
    // D_[i] = dystans trasy 0->1->...->i
    for (int i = 1; i <= count; ++i) {
        int curr_node = giant_tour[start_idx + i - 1];
        int curr_idx = (curr_node > 1) ? curr_node - 1 : 0;

        double dist = 0.0;
        if (i > 1) {
            int prev_node = giant_tour[start_idx + i - 2];
            int prev_idx = (prev_node > 1) ? prev_node - 1 : 0;
            dist = evaluator_->GetDist(prev_idx, curr_idx);
        }

        D_[i] = D_[i - 1] + dist;
        Q_[i] = Q_[i - 1] + evaluator_->GetDemand(curr_node);
    }

    // 3. Algorytm SPLIT (Liniowy O(N) z Kolejk¹ Monotoniczn¹)
    dq_.clear();
    dq_.push_back(0);

    for (int i = 1; i <= count; ++i) {
        int curr_node = giant_tour[start_idx + i - 1];
        int curr_idx = (curr_node > 1) ? curr_node - 1 : 0;

        // A. Ograniczenie Pojemnoœci:
        // Usuwamy z pocz¹tku kolejki wêz³y, które s¹ zbyt daleko (demand > capacity)
        while (!dq_.empty() && (Q_[i] - Q_[dq_.front()] > capacity)) {
            dq_.pop_front();
        }

        // Jeœli kolejka pusta -> brak legalnego podzia³u (Infeasible)
        if (dq_.empty()) {
            V_[i] = 1e30;
            continue;
        }

        // B. Wybór Najlepszego Poprzednika (Front kolejki jest optymalny)
        int best = dq_.front();

        int start_node = giant_tour[start_idx + best]; // Pierwszy klient nowego segmentu
        int s_idx = (start_node > 1) ? start_node - 1 : 0;

        // Koszt = V[best] + Dojazd_z_Depo + Trasa_Wewn + Powrot_do_Depo
        double d_in = evaluator_->GetDist(depot_idx_, s_idx);
        double d_out = evaluator_->GetDist(curr_idx, depot_idx_);
        double d_route = D_[i] - D_[best + 1]; // Dystans wewn¹trz segmentu (bez dojazdów)

        V_[i] = V_[best] + d_in + d_route + d_out;
        pred_[i] = best;

        // C. Aktualizacja Kolejki dla przysz³ych kroków (i+1...)
        if (i < count) {
            int next_node = giant_tour[start_idx + i];
            int next_idx = (next_node > 1) ? next_node - 1 : 0;
            double next_in = evaluator_->GetDist(depot_idx_, next_idx);

            // Wartoœæ "potencja³u" dla i jako poprzednika
            double val_i = V_[i] - D_[i + 1] + next_in;

            // Utrzymanie monotonicznoœci: usuwamy z ty³u gorsze opcje
            while (!dq_.empty()) {
                int back = dq_.back();

                int back_next = giant_tour[start_idx + back];
                int back_idx = (back_next > 1) ? back_next - 1 : 0;
                double back_in = evaluator_->GetDist(depot_idx_, back_idx);

                double val_back = V_[back] - D_[back + 1] + back_in;

                if (val_i <= val_back) {
                    dq_.pop_back();
                }
                else {
                    break;
                }
            }
            dq_.push_back(i);
        }
    }

    if (V_[count] >= 1e29) return; // Nie uda³o siê podzieliæ

    // 4. Rekonstrukcja Segmentów
    segments_buffer_.clear();
    int curr = count;
    while (curr > 0) {
        int prev = pred_[curr];
        // Segment obejmuje klientów od indeksu relative (prev+1) do (curr)
        segments_buffer_.push_back({ prev + 1, curr, (double)(Q_[curr] - Q_[prev]) });
        curr = prev;
    }
    // Segments s¹ w kolejnoœci od koñca do pocz¹tku. Iterujemy odwrotnie.

    // 5. Przypisanie Segmentów do Grup (Heurystyka G³osowania)
    // Wa¿ne: Chcemy przypisaæ segment tam, gdzie pasuje geometrycznie.

    // Reset g³osów
    std::fill(votes_buffer_.begin(), votes_buffer_.end(), 0);

    // Zbieramy g³osy od s¹siadów w ca³ej puli (dla stabilnoœci)
    if (geometry) {
        for (int k = 1; k <= count; ++k) {
            int c_id = giant_tour[start_idx + k - 1];
            int gene_idx = c_id - 2;
            if (gene_idx >= 0) {
                const auto& neighbors = geometry->GetNeighbors(gene_idx);
                for (int neighbor : neighbors) {
                    if (neighbor < (int)genes.size()) {
                        int ng = genes[neighbor];
                        if (ng >= 0 && ng < num_groups) votes_buffer_[ng]++;
                    }
                }
            }
        }
    }

    // Prosta pêtla przypisania (odwrócona kolejnoœæ segmentów)
    for (int i = (int)segments_buffer_.size() - 1; i >= 0; --i) {
        const auto& seg = segments_buffer_[i];

        int best_g = 0; // Default
        int max_votes = -1;

        // Wybór grupy z najwiêksz¹ liczb¹ g³osów w okolicy
        for (int g = 0; g < num_groups; ++g) {
            if (votes_buffer_[g] > max_votes) {
                max_votes = votes_buffer_[g];
                best_g = g;
            }
        }

        // Jeœli remis lub brak g³osów -> losowo (Load Balancing przejmie rolê)
        if (max_votes <= 0) best_g = rand() % num_groups;

        // Aplikacja zmian w genotypie
        for (int k = seg.start_k; k <= seg.end_k; ++k) {
            int c_id = giant_tour[start_idx + k - 1];
            int gene_idx = c_id - 2;
            if (gene_idx >= 0 && gene_idx < (int)genes.size()) {
                genes[gene_idx] = best_g;
            }
        }
    }
}



SplitResult Split::RunLinear(const std::vector<int>& giant_tour) {
    PrecomputeStructures(giant_tour);
    int n = static_cast<int>(giant_tour.size());
    V_[0] = 0.0;

    std::deque<int> dq;
    dq.push_back(0);

    for (int i = 1; i <= n; ++i) {
        int curr_id = giant_tour[i - 1];
        int curr_idx = (curr_id > 1) ? curr_id - 1 : 0;

        while (!dq.empty()) {
            int front = dq.front();

            if (Q_[i] - Q_[front] > capacity_) {
                dq.pop_front();
                continue;
            }
            // Logika distance constraint usuniêta lub uproszczona w tej wersji dla szybkoœci, 
            // jeœli nie jest wymagana przez instancjê.
            break;
        }

        if (dq.empty()) {
            V_[i] = std::numeric_limits<double>::max();
            continue;
        }

        int best_pred = dq.front();

        int start_node_id = giant_tour[best_pred];
        int start_idx = (start_node_id > 1) ? start_node_id - 1 : 0;

        double d_depot_start = evaluator_->GetDist(depot_idx_, start_idx);
        double d_end_depot = evaluator_->GetDist(curr_idx, depot_idx_);
        double d_internal = D_[i] - D_[best_pred + 1];

        V_[i] = V_[best_pred] + d_depot_start + d_internal + d_end_depot;
        pred_[i] = best_pred;

        if (i < n) {
            if (V_[i] >= std::numeric_limits<double>::max()) continue;

            int next_node_id = giant_tour[i];
            int next_idx = (next_node_id > 1) ? next_node_id - 1 : 0;

            double d_depot_next = evaluator_->GetDist(depot_idx_, next_idx);
            double val_i = V_[i] + d_depot_next - D_[i + 1];

            while (!dq.empty()) {
                int back = dq.back();
                int back_next_id = giant_tour[back];
                int back_next_idx = (back_next_id > 1) ? back_next_id - 1 : 0;

                double d_depot_back_next = evaluator_->GetDist(depot_idx_, back_next_idx);
                double val_back = V_[back] + d_depot_back_next - D_[back + 1];

                if (val_i <= val_back) {
                    dq.pop_back();
                }
                else {
                    break;
                }
            }
            dq.push_back(i);
        }
    }

    return ReconstructResult(giant_tour);
}

SplitResult Split::RunBellman(const std::vector<int>& giant_tour) {
    PrecomputeStructures(giant_tour);
    int n = static_cast<int>(giant_tour.size());

    for (int i = 0; i <= n; ++i) V_[i] = 1e30;
    V_[0] = 0.0;

    for (int i = 1; i <= n; ++i) {
        int curr_id = giant_tour[i - 1];
        int curr_idx = curr_id - 1;

        for (int j = i - 1; j >= 0; --j) {
            int load = Q_[i] - Q_[j];
            if (load > capacity_) break;

            int start_node_id = giant_tour[j];
            int start_node_idx = start_node_id - 1;

            double d_depot_start = evaluator_->GetDist(depot_idx_, start_node_idx);
            double d_end_depot = evaluator_->GetDist(curr_idx, depot_idx_);
            double d_internal = D_[i] - D_[j + 1];

            double route_cost = d_depot_start + d_internal + d_end_depot;

            if (V_[j] + route_cost < V_[i]) {
                V_[i] = V_[j] + route_cost;
                pred_[i] = j;
            }
        }
    }
    return ReconstructResult(giant_tour);
}

SplitResult Split::ReconstructResult(const std::vector<int>& giant_tour) {
    SplitResult res;
    int n = static_cast<int>(giant_tour.size());

    if (V_[n] >= std::numeric_limits<double>::max()) {
        res.feasible = false;
        res.total_cost = std::numeric_limits<double>::max();
        return res;
    }

    res.feasible = true;
    res.total_cost = V_[n];

    int curr = n;
    while (curr > 0) {
        int prev = pred_[curr];
        std::vector<int> route;
        route.reserve(curr - prev);
        for (int k = prev + 1; k <= curr; ++k) {
            route.push_back(giant_tour[k - 1]);
        }
        res.optimized_routes.push_back(route);
        curr = prev;
    }
    std::reverse(res.optimized_routes.begin(), res.optimized_routes.end());

    res.group_assignment.assign(num_customers_, 0);

    for (size_t r_idx = 0; r_idx < res.optimized_routes.size(); ++r_idx) {
        for (int cust_id : res.optimized_routes[r_idx]) {
            int gene_idx = cust_id - 2;
            if (gene_idx >= 0 && gene_idx < num_customers_) {
                res.group_assignment[gene_idx] = static_cast<int>(r_idx);
            }
        }
    }
    return res;
}

void Split::PrecomputeStructures(const std::vector<int>& giant_tour) {
    int count = static_cast<int>(giant_tour.size());

    // Upewniamy siê, ¿e struktury pomocnicze maj¹ odpowiedni rozmiar
    // +1, poniewa¿ algorytm Split u¿ywa indeksowania 1..N, gdzie 0 to stan pocz¹tkowy
    ResizeStructures(count + 1);

    D_[0] = 0.0;
    Q_[0] = 0;
    // V_ i pred_ zostan¹ nadpisane w algorytmie w³aœciwym, ale mo¿na je wyzerowaæ
    V_[0] = 0.0;

    // Obliczamy skumulowany dystans (D_) i skumulowane zapotrzebowanie (Q_)
    for (int i = 1; i <= count; ++i) {
        int curr_node = giant_tour[i - 1];
        // Konwersja ID na indeks macierzy (zgodnie z logik¹ w Twoim ApplyMicroSplit)
        // Zak³adamy, ¿e ID > 1 to klienci, a 1 (lub inna wartoœæ) to depot mapowany na 0
        int curr_idx = (curr_node > 1) ? curr_node - 1 : 0;

        double dist = 0.0;
        if (i > 1) {
            int prev_node = giant_tour[i - 2];
            int prev_idx = (prev_node > 1) ? prev_node - 1 : 0;
            dist = evaluator_->GetDist(prev_idx, curr_idx);
        }

        D_[i] = D_[i - 1] + dist;
        Q_[i] = Q_[i - 1] + evaluator_->GetDemand(curr_node);
    }
}